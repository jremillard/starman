#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <graphics.h>
#include <conio.h>
#include <time.h>
#include "object.hpp"

#define MISS_LEFT 0
#define MISS_RIGHT 1
#define NOTHING 2

// ring start
class node
{
static long int next_indx;
public:
long int indx;
node *next;
object *data;
node(object *in) { data = in; indx = next_indx; ++next_indx; };
};

class ring
{
node *list;
node *last;
int num;

public:
object* d(void) { return list->data;};
ring(void);

long int index(void) { return(list->indx); };
int& num_left(void) { return num; };
void add(object *in);
void next(void) { last = list; list = list->next;};
void del(void);
};

long int node::next_indx = 0;

void ring::del(void)
{
list->data->clear();

delete list->data;

if (last != list)
	{
	last->next = list->next;
	delete list;
	list = last;
	--num;
	}
else
	{
	delete list;
	last = NULL;
	list = NULL;
	--num;
	if (num != 0)
		{
		printf("Internial error num not equal to zero in ring::class\n");
		exit(0);
		}
	}
}

ring::ring(void)
{
list = NULL;
last = NULL;
num = 0;
}

void ring::add(object *in)
{
if (list == NULL)
	{
	list = new node(in);
	list->next = list;
	}
else
	{
	node *temp = new node(in);
	temp->next = list->next;
	list->next = temp;
	}
next();
++num;
}
// ring end
class wall: public object
	{
	double x_2,y_2;
	public:
	wall(double x,double y,double x2,double y2,int dir);
	double x2(void) { return x_2;};
	double y2(void) { return y_2;};
	void show(void);
	void clear(void) {};
	};

inline void wall::show(void)
	{
	setcolor(15);
	line(xcor,ycor,x_2,y_2);
	}

wall::wall(double x,double y,double x2,double y2,int dir=0) :
object('w',x,y,dir,0,0,1)
	{
	wall::x_2 = x2;
	wall::y_2 = y2;
	speed(0);
	}

class missle : public object
	{
	char mind[60][10][3];
	public:
	missle(double x,double y, int dir);
	double eval(int x,int y,int level);
	void show(void);
	void clear(void);
	};

missle::missle(double x = 0,double y = 0,int dir=0) :
object('m',x-12*cos(3.141592*dir/180),y-12*sin(3.141592*dir/180),dir,60,-1,1)
 {
 speed(100);
 for (int xcount = 0 ; xcount < 60 ; ++xcount)
	 for (int ycount = 0; ycount < 10; ++ycount)
		 {
		 mind[xcount][ycount][MISS_LEFT] = ycount;
		 mind[xcount][ycount][MISS_RIGHT] = -ycount + 10;
		 mind[xcount][ycount][NOTHING] = 3;
		 }
 }
double missle::eval(int x,int y,int level)
{
if ((x > 0) && (x < 60) && (y > 0) && (y < 10))
	return((double)mind[x][y][level]);
else
	{
	return(0);
	}
}

void missle::show(void)
{
const double pi = 3.141592;
double rad_head = pi*current_heading/180;
setcolor(13);
moveto(xcor,ycor);
linerel(4*cos(rad_head),4*sin(rad_head));
setcolor(15);
}

void missle::clear(void)
{
setcolor(0);
const double pi = 3.141592;
double rad_head = pi*current_heading/180;
moveto(xcor,ycor);
linerel(4*cos(rad_head),4*sin(rad_head));
setcolor(15);
}

class tank : public object
	{
	char mind[60][60][LEVEL];

	public:
	tank(double x,double y,int dir);
	double eval(int x, int y, int level);
	void show(void);
	void clear(void);
	};

double tank::eval(int x, int y, int level)
{
if ((x > 59) || (x < 0) || (y < 0) || (y > 59))
	 return(0);
return( (double)mind[x][y][level] );
}

void tank::show(void)
	{
	const double pi=3.141592;
	double rad_head = pi*current_heading/180;
	moveto(xcor,ycor);
	lineto(xcor-7*cos(rad_head),ycor-7*sin(rad_head));
	moveto(xcor,ycor);
	lineto(xcor+5*cos(rad_head+pi/2),ycor+5*sin(rad_head+pi/2));

	linerel(7*cos(rad_head),7*sin(rad_head));
	linerel(-14*cos(rad_head),-14*sin(rad_head));

	moveto(xcor,ycor);
	lineto(xcor-5*cos(rad_head+pi/2),ycor-5*sin(rad_head+pi/2));

	linerel(7*cos(rad_head),7*sin(rad_head));
	linerel(-14*cos(rad_head),-14*sin(rad_head));
	}

void tank::clear(void)
	{
	setcolor(0);
	const double pi=3.141592;
	double rad_head = pi*current_heading/180;
	moveto(xcor,ycor);
	lineto(xcor-7*cos(rad_head),ycor-7*sin(rad_head));
	moveto(xcor,ycor);
	lineto(xcor+5*cos(rad_head+pi/2),ycor+5*sin(rad_head+pi/2));

	linerel(7*cos(rad_head),7*sin(rad_head));
	linerel(-14*cos(rad_head),-14*sin(rad_head));

	moveto(xcor,ycor);
	lineto(xcor-5*cos(rad_head+pi/2),ycor-5*sin(rad_head+pi/2));

	linerel(7*cos(rad_head),7*sin(rad_head));
	linerel(-14*cos(rad_head),-14*sin(rad_head));
	setcolor(15);
	}

tank::tank(double x,double y,int dir) : object('t',x,y,dir,40,-10,10)
{

speed(15);
for (int xcount=0; xcount < 60; ++xcount)
	for (int ycount=0; ycount < 60; ++ycount)
		{
		mind[xcount][ycount][FIRE] = xcount *4;
		mind[xcount][ycount][EN_RIGHT] = 30;
		mind[xcount][ycount][EN_LEFT] = 29;
		mind[xcount][ycount][SPEED_UP] = xcount * 4;
		mind[xcount][ycount][SPEED_DOWN] = (xcount * -4) +241;
		mind[xcount][ycount][DO_NOTHING] = 100;
		}
}

main()
{
tank *tank1 = new tank(400,400,0);
ring *stuff = new ring();
void check_hits(ring*);
double atan(double,double);

int think(ring*);
int level;

stuff->add(tank1);
stuff->add(new tank(400,200,270));
stuff->add(new wall(1,1,630,1));
stuff->add(new wall(1,1,1,470));
stuff->add(new wall(1,470,630,470));
stuff->add(new wall(630,470,630,1));

char keyin;
	 /* request auto detection */
   int gdriver = DETECT, gmode, errorcode;

   /* initialize graphics an`d local variables */
	 initgraph(&gdriver, &gmode, "c:\\tc\\bgi");

   /* read result of initialization */
   errorcode = graphresult();
   if (errorcode != grOk)
   {
      printf("Graphics error: %s\n",
         grapherrormsg(errorcode));
      printf("Press any key to halt:");
      getch();
      exit(1);
	 }
	 while ((keyin != 'q') && (stuff->num_left() > 1))
		 {
		 while ((kbhit() == 0) && (stuff->num_left() > 1))
			{
			stuff->next();
			stuff->d()->move();
			if (stuff->d()->obj_type() != 'w')
				{
				check_hits(stuff);
				level = think(stuff);

				if (stuff->d()->obj_type() == 't')
					switch (level)
						{
						case FIRE:
							stuff->add(new missle(stuff->d()->x(),stuff->d()->y(),stuff->d()->head()));
							break;
						case EN_RIGHT:
							stuff->d()->turn(1);
							break;
						case EN_LEFT:
							stuff->d()->turn(-1);
							break;
						case SPEED_UP:
							stuff->d()->speed(5);
							break;
						case SPEED_DOWN:
							stuff->d()->speed(-5);
							break;
						case DO_NOTHING:
							break;
						default:
							printf("Think returned a invalide number tank %d\n",level);
							break;
						}
				if (stuff->d()->obj_type() == 'm')
					 switch (level)
						{
						case MISS_LEFT:
							stuff->d()->turn(1);
							break;
						case MISS_RIGHT:
							stuff->d()->turn(-1);
							break;
						case NOTHING:
							break;
						default:
							printf("Think retruned a invalide number missle\n");
						break;
						}
					}
			}
		 keyin = getch();
		 switch (keyin)
			{
			case '8':
				tank1->speed(5);
				break;
			case '2':
				tank1->speed(-5);
				break;
			case '4':
				tank1->turn(-5);
				break;
			case '6':
				tank1->turn(5);
				break;
			case '5':
				if (stuff->d()->obj_type() == 't')
					stuff->add(new missle(stuff->d()->x(),stuff->d()->y(),stuff->d()->head()));
				break;
			defualt:
				break;
			}
		 }

	 closegraph();
	 return 0;
}

int think(ring *stuff)
{
long int index = stuff->index();
object *orig;
orig = stuff->d();
double x = stuff->d()->x();
double y = stuff->d()->y();
double dist,angle;
int xindx,yindx;
int level[LEVEL] = {0,0,0,0,0,0};
double atan(double,double);
int max_indx(int*,int);
int max;

char base_type = stuff->d()->obj_type();

double wall_dist(ring*,double,double);

stuff->next();

max = LEVEL;

while(index != stuff->index() )
 if (stuff->d()->obj_type() != 'w')
	{
	double newx = stuff->d()->x();
	double newy = stuff->d()->y();
	dist = sqrt( ((newx - x)*(newx - x)) + ((newy - y)*(newy - y)) );
	angle = atan(newy-y,newx-x);
	angle = angle - ((stuff->d()->head() * 3.141592) / 180);
	xindx = dist * cos(angle);
	yindx = dist * cos(angle);
	max = LEVEL;
	if (base_type == 'm')
		max = 3;

	for (int count = 0; count < max; ++count)
		level[count] += orig->eval(xindx,yindx,max);

	stuff->next();
	}
	else stuff->next();

	return(max_indx(level,max));

}

int max_indx(int *level,int max)
{
int winner = max-1;
int high = 0;

for (int count=0; count < max; ++count)
	if (level[count] > high) winner = count;

return(winner);
}

double atan(double y,double x)
{
double angle = atan(y/x);
if ((y < 0) && (x < 0)) return(angle + 3.141592);
if ((y > 0) && (x < 0)) return(angle + 3.141592);
return(angle);
}

void check_hits(ring *stuff)
{
long int index = stuff->index();
double x = stuff->d()->x();
double y = stuff->d()->y();
double dist;
char hit = FALSE;
char score = FALSE;
char base_type = stuff->d()->obj_type();

double wall_dist(ring*,double,double);

stuff->next();

while(index != stuff->index() )
	{
	char comp_type = stuff->d()->obj_type();
	if (comp_type != 'w')
		{
		double newx = stuff->d()->x();
		double newy = stuff->d()->y();
		dist = sqrt( ((newx - x)*(newx - x)) + ((newy - y)*(newy - y)) );
		}
	else
		dist = wall_dist(stuff,x,y);
	switch (base_type)
		{
		case 't':
			switch (comp_type)
				{
				case 't':
					if (dist < 16)
						{
						score = TRUE;
						hit = TRUE;
						}
					break;
				case 'm':
					if (dist < 9)
						{
						score = TRUE;
						hit = TRUE;
						}
					break;
				case 'w':
					if (dist < 9)
						hit = TRUE;
					break;
				default:
					printf("Unknown object type in check_hit\n");
					exit(0);
				}
			break;
		case 'm':
			switch (comp_type)
				{
				case 'm':
					if (dist < 4)
						{
						score = TRUE;
						hit = TRUE;
						}
					break;
				case 't':
					if (dist < 9)
						{
						score = TRUE;
						hit = TRUE;
						}
					break;
				case 'w':
					if (dist < 4)
						hit = TRUE;
					break;
				defualt:
					printf("Unknown object type in check_hit\n");
					exit(0);
				}
			break;
		default:
			printf("Unknown object type in check_hit \n");
			exit(0);
		}
	if (score == TRUE)
		stuff->del();

	stuff->next();
	score = FALSE;
	}

if (hit == TRUE)
	stuff->del();
}

double wall_dist(ring *stuff,double x, double y)
{
double x1 = stuff->d()->x();
double y1 = stuff->d()->y();
double x2 = stuff->d()->x2();
double y2 = stuff->d()->y2();

double slope = (y2-y1+.000001) / (x2 - x1 + .000001);
double b1 = y1 - x2 * slope;

if (abs(slope) < .00001) slope = .00001;

double slope2 = 1 / slope;

double b2 = y - slope2*x;

double delta = slope - slope2 + .00001;

double deltay = (b2*slope) - (b1*slope2);
double deltax = (b2 - b1);

double solx = deltax / delta;
double soly = deltay / delta;

double dist = sqrt( (solx-x)*(solx-x) + (soly-y)*(soly-y));
return dist;
}
 